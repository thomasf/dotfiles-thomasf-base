# -*- mode: sh -*-

# All functions in this file are supposed to be used interactivley

source ~/.config-base/bash/common


# ----------------------------------------------------------------------------
#

rehistory() {
  history -r
}

# rebash reloads all shell init stuff
rebash() {
  unset __common
  unset __SHCOMMON
  . "${HOME}/.bash_profile"
}
export -f rebash


# bind ctrl-t to an fzf file/dir selector to insert at cursor location.
__fzf_select_dir ()
{
  builtin typeset READLINE_LINE_NEW="$(
                command find -L . \( -path '*/\.*' -o -fstype dev -o -fstype proc \) \
                        -prune \
                        -o -type f -print \
                        -o -type d -print \
                        -o -type l -print 2>/dev/null \
                | command sed 1d \
                | command cut -b3- \
                | env fzf +s -m
        )"

  if
    [[ -n $READLINE_LINE_NEW ]]
  then
    builtin bind '"\er": redraw-current-line'
    builtin bind '"\e^": magic-space'
    READLINE_LINE=${READLINE_LINE:+${READLINE_LINE:0:READLINE_POINT}}${READLINE_LINE_NEW}${READLINE_LINE:+${READLINE_LINE:READLINE_POINT}}
    READLINE_POINT=$(( READLINE_POINT + ${#READLINE_LINE_NEW} ))
  else
    builtin bind '"\er":'
    builtin bind '"\e^":'
  fi
}

if hash fzf 2>/dev/null; then
  builtin bind -x '"\C-x1": __fzf_select_dir'
  builtin bind '"\C-t": "\C-x1\e^\er"'
fi

__fzf_history () {
  builtin typeset \
          READLINE_LINE_NEW="$(
            HISTTIMEFORMAT= builtin history |
            command fzf -e +s --tac +m -n2..,.. --tiebreak=index  --toggle-sort=ctrl-r  |
            command sed '
                /^ *[0-9]/ {
                    s/ *\([0-9]*\) .*/!\1/;
                    b end;
                };
                d;
                : end
            '
        )";

  if
    [[ -n $READLINE_LINE_NEW ]]
  then
    builtin bind '"\er": redraw-current-line'
    builtin bind '"\e^": magic-space'
    READLINE_LINE=${READLINE_LINE:+${READLINE_LINE:0:READLINE_POINT}}${READLINE_LINE_NEW}${READLINE_LINE:+${READLINE_LINE:READLINE_POINT}}
    READLINE_POINT=$(( READLINE_POINT + ${#READLINE_LINE_NEW} ))
  else
    builtin bind '"\er":'
    builtin bind '"\e^":'
  fi
}

if hash fzf 2>/dev/null; then
  builtin set -o histexpand;
  builtin bind -x '"\C-x2": __fzf_history';
  builtin bind '"\C-r": "\C-x2\e^\er"'
fi
